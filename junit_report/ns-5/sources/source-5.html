


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ShapePanel</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">ui</a>
</div>

<h1>Coverage Summary for Class: ShapePanel (ui)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ShapePanel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/83)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package ui;
&nbsp;import org.locationtech.jts.geom.Geometry;
&nbsp;import org.locationtech.jts.geom.MultiPolygon;
&nbsp;import org.locationtech.jts.geom.Polygon;
&nbsp;import core.Constants;
&nbsp;
&nbsp;import javax.swing.*;
&nbsp;import java.awt.*;
&nbsp;import java.awt.geom.AffineTransform;
&nbsp;import java.awt.geom.Path2D;
&nbsp;import java.util.Random;
&nbsp;
&nbsp;/**
&nbsp; * Painel para renderização de formas geométricas com estilo personalizado.
&nbsp; * Suporta vários tipos de geometria e fornece visualização interativa.
&nbsp; * 
&nbsp; * @author Lei-G
&nbsp; * @version 1.0
&nbsp; * @see javax.swing.JPanel
&nbsp; * @see org.locationtech.jts.geom.Geometry
&nbsp; * @see org.locationtech.jts.geom.Polygon
&nbsp; * @see org.locationtech.jts.geom.MultiPolygon
&nbsp; */
&nbsp;public class ShapePanel extends JPanel {
&nbsp;    
&nbsp;    /** The geometry to be rendered in this panel */
&nbsp;    private final Geometry geometry;
&nbsp;    /** Color used for rendering the shape */
&nbsp;    private final Color color;
&nbsp;    /** Unique identifier for the shape, used for color generation */
&nbsp;    private final String id;
&nbsp;
&nbsp;    /**
&nbsp;     * Cria um novo painel para visualização de uma forma geométrica.
&nbsp;     * 
&nbsp;     * @param geometry A geometria a visualizar
&nbsp;     * @param id Identificador único para geração de cor
&nbsp;     */
<b class="nc">&nbsp;    public ShapePanel(Geometry geometry, String id) {</b>
<b class="nc">&nbsp;        if (geometry == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(Constants.NULL_GEOMETRY_ERROR);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.geometry = geometry;</b>
<b class="nc">&nbsp;        this.color = generateColorFromId(id);</b>
<b class="nc">&nbsp;        this.id = id;</b>
<b class="nc">&nbsp;        setBackground(Color.WHITE);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    private Color generateColorFromId(String id) {
<b class="nc">&nbsp;        Random rand = new Random(id.hashCode()); // Semear com o ID para garantir cor consistente</b>
&nbsp;
<b class="nc">&nbsp;        int r = rand.nextInt(256); // 0-255</b>
<b class="nc">&nbsp;        int g = rand.nextInt(256);</b>
<b class="nc">&nbsp;        int b = rand.nextInt(256);</b>
&nbsp;
<b class="nc">&nbsp;        return new Color(r, g, b);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Paints the component, rendering the geometric shape.
&nbsp;     * Applies transformations to center and scale the shape
&nbsp;     * appropriately on the panel.
&nbsp;     *
&nbsp;     * @param g Graphics object used for painting
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected void paintComponent(Graphics g) {
&nbsp;        try {
<b class="nc">&nbsp;            super.paintComponent(g);</b>
<b class="nc">&nbsp;            Graphics2D g2d = (Graphics2D) g;</b>
<b class="nc">&nbsp;            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</b>
<b class="nc">&nbsp;            AffineTransform transform = calculateTransform();</b>
<b class="nc">&nbsp;            g2d.transform(transform);</b>
<b class="nc">&nbsp;            drawGeometry(g2d, geometry);</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            drawError(g);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Draws a message error on the panel.
&nbsp;     * 
&nbsp;     * @param g Graphics object used for painting
&nbsp;     */
&nbsp;    private void drawError(Graphics g) {
<b class="nc">&nbsp;        g.setColor(Color.RED);</b>
<b class="nc">&nbsp;        g.drawString(Constants.RENDER_GEOMETRY_ERROR, 10, 20);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculates the transformation needed to center and scale the shape.
&nbsp;     * The transformation includes translation, scaling, and Y axis inversion.
&nbsp;     *
&nbsp;     * @return AffineTransform object representing the transformation
&nbsp;     * @throws IllegalStateException if there is an error calculating the transformation
&nbsp;     */
&nbsp;    private AffineTransform calculateTransform() {
&nbsp;        try {
<b class="nc">&nbsp;            double minX = geometry.getEnvelopeInternal().getMinX();</b>
<b class="nc">&nbsp;            double maxX = geometry.getEnvelopeInternal().getMaxX();</b>
<b class="nc">&nbsp;            double minY = geometry.getEnvelopeInternal().getMinY();</b>
<b class="nc">&nbsp;            double maxY = geometry.getEnvelopeInternal().getMaxY();</b>
&nbsp;            
<b class="nc">&nbsp;            if (Double.isInfinite(minX) || Double.isInfinite(maxX) || </b>
<b class="nc">&nbsp;                Double.isInfinite(minY) || Double.isInfinite(maxY)) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(Constants.INVALID_COORDINATES_ERROR);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            double width = maxX - minX;</b>
<b class="nc">&nbsp;            double height = maxY - minY;</b>
&nbsp;            
<b class="nc">&nbsp;            if (width &lt;= 0 || height &lt;= 0) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(Constants.INVALID_DIMENSIONS_ERROR);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            double scaleX = (getWidth() * Constants.SHAPE_SCALE_FACTOR) / width;</b>
<b class="nc">&nbsp;            double scaleY = (getHeight() * Constants.SHAPE_SCALE_FACTOR) / height;</b>
<b class="nc">&nbsp;            double scale = Math.min(scaleX, scaleY);</b>
&nbsp;
<b class="nc">&nbsp;            AffineTransform transform = new AffineTransform();</b>
<b class="nc">&nbsp;            transform.translate(getWidth() / 2, getHeight() / 2);</b>
<b class="nc">&nbsp;            transform.scale(1, -1);</b>
<b class="nc">&nbsp;            transform.scale(scale, scale);</b>
<b class="nc">&nbsp;            transform.translate(-(minX + width / 2), -(minY + height / 2));</b>
&nbsp;            
<b class="nc">&nbsp;            return transform;</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(Constants.TRANSFORM_ERROR + e.getMessage(), e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws geometry on the Graphics2D object.
&nbsp;     * Supports MultiPolygon and Polygon.
&nbsp;     *
&nbsp;     * @param g2d Graphics context
&nbsp;     * @param geom Geometry to draw
&nbsp;     */
&nbsp;    private void drawGeometry(Graphics2D g2d, Geometry geom) {
&nbsp;        try {
<b class="nc">&nbsp;            if (geom instanceof MultiPolygon multiPolygon) {</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; multiPolygon.getNumGeometries(); i++) {</b>
<b class="nc">&nbsp;                    Polygon polygon = (Polygon) multiPolygon.getGeometryN(i);</b>
<b class="nc">&nbsp;                    drawPolygon(g2d, polygon);</b>
&nbsp;                }
<b class="nc">&nbsp;            } else if (geom instanceof Polygon polygon) {</b>
<b class="nc">&nbsp;                drawPolygon(g2d, polygon);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                throw new IllegalArgumentException(Constants.UNSUPPORTED_GEOMETRY_ERROR + geom.getClass().getSimpleName());</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            throw new RuntimeException(Constants.DRAW_GEOMETRY_ERROR, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Draws a polygon with custom styling.
&nbsp;     * Fills with semi-transparent blue, outlines in blue.
&nbsp;     * Holes are filled with background color and outlined in red.
&nbsp;     *
&nbsp;     * @param g2d Graphics context
&nbsp;     * @param polygon Polygon to draw
&nbsp;     */
&nbsp;    private void drawPolygon(Graphics2D g2d, Polygon polygon) {
&nbsp;        try {
<b class="nc">&nbsp;            if (polygon == null) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(Constants.NULL_GEOMETRY_ERROR);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Path2D path = toPath2D(polygon.getExteriorRing());</b>
<b class="nc">&nbsp;            g2d.setColor(color);</b>
<b class="nc">&nbsp;            g2d.fill(path);</b>
<b class="nc">&nbsp;            g2d.setColor(color);</b>
<b class="nc">&nbsp;            g2d.draw(path);</b>
&nbsp;
<b class="nc">&nbsp;            for (int i = 0; i &lt; polygon.getNumInteriorRing(); i++) {</b>
<b class="nc">&nbsp;                Path2D hole = toPath2D(polygon.getInteriorRingN(i));</b>
<b class="nc">&nbsp;                g2d.setColor(getBackground());</b>
<b class="nc">&nbsp;                g2d.fill(hole);</b>
<b class="nc">&nbsp;                g2d.setColor(Constants.HOLE_BORDER);</b>
<b class="nc">&nbsp;                g2d.draw(hole);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(Constants.DRAW_POLYGON_ERROR, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Converts a Geometry object to a Path2D object.
&nbsp;     * Creates a closed path from the geometry coordinates.
&nbsp;     *
&nbsp;     * @param geometry Geometry to convert
&nbsp;     * @return Path2D object representing the geometry
&nbsp;     * @throws IllegalArgumentException if the geometry is null or invalid
&nbsp;     */
&nbsp;    private Path2D toPath2D(Geometry geometry) {
&nbsp;        try {
<b class="nc">&nbsp;            if (geometry == null) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(Constants.NULL_GEOMETRY_ERROR);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            Path2D path = new Path2D.Double();</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; geometry.getNumPoints(); i++) {</b>
<b class="nc">&nbsp;                double x = geometry.getCoordinates()[i].x;</b>
<b class="nc">&nbsp;                double y = geometry.getCoordinates()[i].y;</b>
&nbsp;                
<b class="nc">&nbsp;                if (Double.isInfinite(x) || Double.isInfinite(y)) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(Constants.INVALID_COORDINATES_ERROR);</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                if (i == 0) {</b>
<b class="nc">&nbsp;                    path.moveTo(x, y);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    path.lineTo(x, y);</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            path.closePath();</b>
<b class="nc">&nbsp;            return path;</b>
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            throw new RuntimeException(Constants.CONVERT_GEOMETRY_ERROR, e);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-05-17 22:49</div>
</div>
</body>
</html>
