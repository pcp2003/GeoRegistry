


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > OwnerGraphPanel</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">ui</a>
</div>

<h1>Coverage Summary for Class: OwnerGraphPanel (ui)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">OwnerGraphPanel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/124)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package ui;
&nbsp;
&nbsp;import service.OwnerGraph;
&nbsp;import model.Cadastro;
&nbsp;import core.Constants;
&nbsp;import org.locationtech.jts.geom.MultiPolygon;
&nbsp;
&nbsp;import javax.swing.*;
&nbsp;import java.awt.*;
&nbsp;import java.awt.event.MouseEvent;
&nbsp;import java.awt.event.MouseListener;
&nbsp;import java.awt.event.MouseMotionListener;
&nbsp;import java.awt.event.MouseWheelEvent;
&nbsp;import java.awt.event.MouseWheelListener;
&nbsp;import java.awt.geom.AffineTransform;
&nbsp;import java.awt.geom.Point2D;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.HashMap;
&nbsp;
&nbsp;/**
&nbsp; * Painel responsável por visualizar o grafo de proprietários.
&nbsp; * Este painel permite visualizar e interagir com o grafo que representa
&nbsp; * as relações entre proprietários e suas propriedades.
&nbsp; * 
&nbsp; * O painel inclui:
&nbsp; * - Visualização do grafo com zoom e pan
&nbsp; * - Lista de proprietários
&nbsp; * - Botões para criar e limpar o grafo
&nbsp; * - Interação com os nós do grafo
&nbsp; * 
&nbsp; * @author LEI-G
&nbsp; * @version 1.0
&nbsp; * @see javax.swing.JPanel
&nbsp; * @see model.Cadastro
&nbsp; * @see service.OwnerGraph
&nbsp; */
&nbsp;public class OwnerGraphPanel extends JPanel implements MouseWheelListener, MouseListener, MouseMotionListener {
&nbsp;    /** O grafo de proprietários a ser visualizado */
&nbsp;    private final OwnerGraph ownerGraph;
&nbsp;    
&nbsp;    /** Fator de zoom atual */
<b class="nc">&nbsp;    private double zoomFactor = 1.0;</b>
&nbsp;    
&nbsp;    /** Ponto de referência para o pan */
&nbsp;    private Point2D lastPoint;
&nbsp;    
&nbsp;    /** Deslocamento atual do pan */
<b class="nc">&nbsp;    private Point2D panOffset = new Point2D.Double(0, 0);</b>
&nbsp;    
&nbsp;    /**
&nbsp;     * Constrói um OwnerGraphPanel com o grafo de proprietários especificado.
&nbsp;     * O painel será dimensionado para 800x600 pixels e terá fundo branco.
&nbsp;     *
&nbsp;     * @param ownerGraph O grafo de proprietários a ser visualizado
&nbsp;     * @throws IllegalArgumentException se o grafo for nulo
&nbsp;     */
<b class="nc">&nbsp;    public OwnerGraphPanel(OwnerGraph ownerGraph) {</b>
<b class="nc">&nbsp;        if (ownerGraph == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(Constants.NULL_GRAPH_ERROR);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.ownerGraph = ownerGraph;</b>
<b class="nc">&nbsp;        setBackground(Color.WHITE);</b>
<b class="nc">&nbsp;        setPreferredSize(Constants.GRAPH_PANEL_SIZE);</b>
<b class="nc">&nbsp;        addMouseWheelListener(this);</b>
<b class="nc">&nbsp;        addMouseListener(this);</b>
<b class="nc">&nbsp;        addMouseMotionListener(this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Pinta o componente, renderizando o grafo de proprietários.
&nbsp;     * Primeiro desenha as adjacências e depois os proprietários,
&nbsp;     * garantindo que as adjacências fiquem atrás dos proprietários.
&nbsp;     * 
&nbsp;     * @param g O objeto Graphics usado para pintura
&nbsp;     */
&nbsp;    @Override
&nbsp;    protected void paintComponent(Graphics g) {
&nbsp;        try {
<b class="nc">&nbsp;            super.paintComponent(g);</b>
<b class="nc">&nbsp;            Graphics2D g2d = (Graphics2D) g;</b>
<b class="nc">&nbsp;            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</b>
&nbsp;            
<b class="nc">&nbsp;            AffineTransform transform = calculateTransform();</b>
<b class="nc">&nbsp;            g2d.transform(transform);</b>
&nbsp;            
&nbsp;            // Agrupa propriedades por proprietário
<b class="nc">&nbsp;            Map&lt;Integer, List&lt;Cadastro&gt;&gt; propertiesByOwner = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;            for (Cadastro cadastro : ownerGraph.getProperties()) {</b>
<b class="nc">&nbsp;                propertiesByOwner.computeIfAbsent(cadastro.getOwner(), e -&gt; new ArrayList&lt;&gt;()).add(cadastro);</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Desenha um ponto por proprietário, no centro médio de suas propriedades
<b class="nc">&nbsp;            for (Map.Entry&lt;Integer, List&lt;Cadastro&gt;&gt; entry : propertiesByOwner.entrySet()) {</b>
<b class="nc">&nbsp;                drawOwnerAtAverageCenter(g2d, entry.getKey(), entry.getValue());</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            drawError(g);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Manipula o evento da roda do mouse para controlar o zoom.
&nbsp;     * 
&nbsp;     * @param e O evento da roda do mouse
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void mouseWheelMoved(MouseWheelEvent e) {
<b class="nc">&nbsp;        double oldZoom = zoomFactor;</b>
&nbsp;        
&nbsp;        // Calcula o novo fator de zoom
<b class="nc">&nbsp;        if (e.getWheelRotation() &lt; 0) {</b>
&nbsp;            // Zoom in
<b class="nc">&nbsp;            zoomFactor = Math.min(zoomFactor + Constants.ZOOM_STEP, Constants.MAX_ZOOM);</b>
&nbsp;        } else {
&nbsp;            // Zoom out
<b class="nc">&nbsp;            zoomFactor = Math.max(zoomFactor - Constants.ZOOM_STEP, Constants.MIN_ZOOM);</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Se o zoom mudou, repinta o painel
<b class="nc">&nbsp;        if (oldZoom != zoomFactor) {</b>
<b class="nc">&nbsp;            repaint();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Manipula o evento de pressionar o botão do mouse.
&nbsp;     * Inicia o pan quando o botão esquerdo é pressionado.
&nbsp;     * 
&nbsp;     * @param e O evento do mouse
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void mousePressed(MouseEvent e) {
<b class="nc">&nbsp;        if (e.getButton() == MouseEvent.BUTTON1) {</b>
<b class="nc">&nbsp;            lastPoint = e.getPoint();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Manipula o evento de soltar o botão do mouse.
&nbsp;     * Finaliza o pan quando o botão esquerdo é solto.
&nbsp;     * 
&nbsp;     * @param e O evento do mouse
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void mouseReleased(MouseEvent e) {
<b class="nc">&nbsp;        if (e.getButton() == MouseEvent.BUTTON1) {</b>
<b class="nc">&nbsp;            lastPoint = null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Manipula o evento de arrastar o mouse.
&nbsp;     * Atualiza o pan quando o mouse é arrastado com o botão esquerdo pressionado.
&nbsp;     * 
&nbsp;     * @param e O evento do mouse
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void mouseDragged(MouseEvent e) {
<b class="nc">&nbsp;        if (lastPoint != null) {</b>
<b class="nc">&nbsp;            double dx = e.getX() - lastPoint.getX();</b>
<b class="nc">&nbsp;            double dy = e.getY() - lastPoint.getY();</b>
&nbsp;            
&nbsp;            // Atualiza o deslocamento do pan
<b class="nc">&nbsp;            panOffset.setLocation(panOffset.getX() + dx, panOffset.getY() + dy);</b>
<b class="nc">&nbsp;            lastPoint = e.getPoint();</b>
&nbsp;            
<b class="nc">&nbsp;            repaint();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // Métodos não utilizados da interface MouseListener
&nbsp;    @Override
<b class="nc">&nbsp;    public void mouseClicked(MouseEvent e) {}</b>
&nbsp;    @Override
<b class="nc">&nbsp;    public void mouseEntered(MouseEvent e) {}</b>
&nbsp;    @Override
<b class="nc">&nbsp;    public void mouseExited(MouseEvent e) {}</b>
&nbsp;    @Override
<b class="nc">&nbsp;    public void mouseMoved(MouseEvent e) {}</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Desenha uma mensagem de erro no painel.
&nbsp;     * 
&nbsp;     * @param g O objeto Graphics usado para pintura
&nbsp;     */
&nbsp;    private void drawError(Graphics g) {
<b class="nc">&nbsp;        g.setColor(Color.RED);</b>
<b class="nc">&nbsp;        g.drawString(Constants.RENDER_ERROR, 10, 20);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calcula a transformação necessária para centralizar e dimensionar o grafo.
&nbsp;     * A transformação inclui:
&nbsp;     * 1. Translação para o centro do painel
&nbsp;     * 2. Inversão do eixo Y (coordenadas do mundo para coordenadas da tela)
&nbsp;     * 3. Escala para caber no painel
&nbsp;     * 4. Translação para a origem do grafo
&nbsp;     * 5. Aplicação do fator de zoom
&nbsp;     * 6. Aplicação do deslocamento do pan
&nbsp;     *
&nbsp;     * @return O objeto AffineTransform representando a transformação
&nbsp;     */
&nbsp;    private AffineTransform calculateTransform() {
<b class="nc">&nbsp;        double minX = Double.MAX_VALUE;</b>
<b class="nc">&nbsp;        double maxX = Double.MIN_VALUE;</b>
<b class="nc">&nbsp;        double minY = Double.MAX_VALUE;</b>
<b class="nc">&nbsp;        double maxY = Double.MIN_VALUE;</b>
&nbsp;
&nbsp;        // Agrupa propriedades por proprietário
<b class="nc">&nbsp;        Map&lt;Integer, List&lt;Cadastro&gt;&gt; propertiesByOwner = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        for (Cadastro cadastro : ownerGraph.getProperties()) {</b>
<b class="nc">&nbsp;            propertiesByOwner.computeIfAbsent(cadastro.getOwner(), e -&gt; new ArrayList&lt;&gt;()).add(cadastro);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Calcula os limites do grafo usando os centros médios
<b class="nc">&nbsp;        for (List&lt;Cadastro&gt; ownerProperties : propertiesByOwner.values()) {</b>
<b class="nc">&nbsp;            double totalX = 0;</b>
<b class="nc">&nbsp;            double totalY = 0;</b>
<b class="nc">&nbsp;            int validProperties = 0;</b>
&nbsp;
<b class="nc">&nbsp;            for (Cadastro cadastro : ownerProperties) {</b>
<b class="nc">&nbsp;                MultiPolygon shape = cadastro.getShape();</b>
<b class="nc">&nbsp;                if (shape != null) {</b>
<b class="nc">&nbsp;                    totalX += shape.getCentroid().getX();</b>
<b class="nc">&nbsp;                    totalY += shape.getCentroid().getY();</b>
<b class="nc">&nbsp;                    validProperties++;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (validProperties &gt; 0) {</b>
<b class="nc">&nbsp;                double avgX = totalX / validProperties;</b>
<b class="nc">&nbsp;                double avgY = totalY / validProperties;</b>
<b class="nc">&nbsp;                minX = Math.min(minX, avgX);</b>
<b class="nc">&nbsp;                maxX = Math.max(maxX, avgX);</b>
<b class="nc">&nbsp;                minY = Math.min(minY, avgY);</b>
<b class="nc">&nbsp;                maxY = Math.max(maxY, avgY);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        double width = maxX - minX;</b>
<b class="nc">&nbsp;        double height = maxY - minY;</b>
&nbsp;
<b class="nc">&nbsp;        double scaleX = (getWidth() * Constants.GRAPH_SCALE_FACTOR) / width;</b>
<b class="nc">&nbsp;        double scaleY = (getHeight() * Constants.GRAPH_SCALE_FACTOR) / height;</b>
<b class="nc">&nbsp;        double scale = Math.min(scaleX, scaleY);</b>
&nbsp;
<b class="nc">&nbsp;        AffineTransform transform = new AffineTransform();</b>
<b class="nc">&nbsp;        transform.translate(getWidth() / 2 + panOffset.getX(), getHeight() / 2 + panOffset.getY());</b>
<b class="nc">&nbsp;        transform.scale(1, -1);</b>
<b class="nc">&nbsp;        transform.scale(scale * zoomFactor, scale * zoomFactor);</b>
<b class="nc">&nbsp;        transform.translate(-(minX + width / 2), -(minY + height / 2));</b>
&nbsp;
<b class="nc">&nbsp;        return transform;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Desenha um proprietário no centro médio de suas propriedades.
&nbsp;     * O tamanho do círculo é proporcional ao número de propriedades.
&nbsp;     * 
&nbsp;     * @param g2d O objeto Graphics2D usado para desenho
&nbsp;     * @param ownerId ID do proprietário
&nbsp;     * @param properties Lista de propriedades do proprietário
&nbsp;     */
&nbsp;    private void drawOwnerAtAverageCenter(Graphics2D g2d, int ownerId, List&lt;Cadastro&gt; properties) {
<b class="nc">&nbsp;        double totalX = 0;</b>
<b class="nc">&nbsp;        double totalY = 0;</b>
<b class="nc">&nbsp;        int validProperties = 0;</b>
&nbsp;
&nbsp;        // Calcula a soma dos centroides
<b class="nc">&nbsp;        for (Cadastro cadastro : properties) {</b>
<b class="nc">&nbsp;            MultiPolygon shape = cadastro.getShape();</b>
<b class="nc">&nbsp;            if (shape != null) {</b>
<b class="nc">&nbsp;                totalX += shape.getCentroid().getX();</b>
<b class="nc">&nbsp;                totalY += shape.getCentroid().getY();</b>
<b class="nc">&nbsp;                validProperties++;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Se houver propriedades válidas, desenha o ponto no centro médio
<b class="nc">&nbsp;        if (validProperties &gt; 0) {</b>
<b class="nc">&nbsp;            double avgX = totalX / validProperties;</b>
<b class="nc">&nbsp;            double avgY = totalY / validProperties;</b>
&nbsp;            
&nbsp;            // Ajusta o raio baseado no número de propriedades
<b class="nc">&nbsp;            double baseRadius = 5.0;</b>
<b class="nc">&nbsp;            double radius = baseRadius * Math.sqrt(validProperties);</b>
&nbsp;            
&nbsp;            // Desenha o círculo
<b class="nc">&nbsp;            g2d.setColor(new Color(0, 128, 0)); // Verde escuro</b>
<b class="nc">&nbsp;            g2d.fill(new java.awt.geom.Ellipse2D.Double(avgX - radius, avgY - radius, radius * 2, radius * 2));</b>
<b class="nc">&nbsp;            g2d.setColor(new Color(0, 100, 0)); // Verde mais escuro para a borda</b>
<b class="nc">&nbsp;            g2d.draw(new java.awt.geom.Ellipse2D.Double(avgX - radius, avgY - radius, radius * 2, radius * 2));</b>
&nbsp;            
&nbsp;            // Salva a transformação atual
<b class="nc">&nbsp;            AffineTransform oldTransform = g2d.getTransform();</b>
&nbsp;            
&nbsp;            // Remove a transformação para desenhar o texto
<b class="nc">&nbsp;            g2d.setTransform(new AffineTransform());</b>
&nbsp;            
&nbsp;            // Converte as coordenadas do mundo para coordenadas da tela
<b class="nc">&nbsp;            Point2D screenPoint = oldTransform.transform(new Point2D.Double(avgX, avgY), null);</b>
<b class="nc">&nbsp;            Point2D radiusPoint = oldTransform.transform(new Point2D.Double(avgX + radius, avgY), null);</b>
<b class="nc">&nbsp;            double screenRadius = radiusPoint.getX() - screenPoint.getX();</b>
&nbsp;            
&nbsp;            // Desenha o ID do proprietário
<b class="nc">&nbsp;            g2d.setColor(Color.WHITE);</b>
<b class="nc">&nbsp;            String ownerIdStr = String.valueOf(ownerId);</b>
&nbsp;            
&nbsp;            // Ajusta o tamanho da fonte para ocupar 60% do diâmetro do círculo
<b class="nc">&nbsp;            double targetWidth = screenRadius * 1.2; // Diâmetro * 0.6</b>
<b class="nc">&nbsp;            Font originalFont = g2d.getFont();</b>
<b class="nc">&nbsp;            Font newFont = findFontSizeToFit(g2d, ownerIdStr, targetWidth, originalFont);</b>
<b class="nc">&nbsp;            g2d.setFont(newFont);</b>
&nbsp;            
<b class="nc">&nbsp;            FontMetrics fm = g2d.getFontMetrics();</b>
<b class="nc">&nbsp;            int textWidth = fm.stringWidth(ownerIdStr);</b>
<b class="nc">&nbsp;            int textHeight = fm.getHeight();</b>
&nbsp;            
<b class="nc">&nbsp;            g2d.drawString(ownerIdStr, </b>
<b class="nc">&nbsp;                (float)(screenPoint.getX() - textWidth/2), </b>
<b class="nc">&nbsp;                (float)(screenPoint.getY() + textHeight/4));</b>
&nbsp;            
&nbsp;            // Restaura a fonte e transformação original
<b class="nc">&nbsp;            g2d.setFont(originalFont);</b>
<b class="nc">&nbsp;            g2d.setTransform(oldTransform);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Encontra o tamanho de fonte adequado para que o texto caiba na largura desejada.
&nbsp;     * 
&nbsp;     * @param g2d O contexto gráfico
&nbsp;     * @param text O texto a ser medido
&nbsp;     * @param targetWidth A largura alvo desejada
&nbsp;     * @param baseFont A fonte base para derivar o novo tamanho
&nbsp;     * @return Uma nova fonte com o tamanho ajustado
&nbsp;     */
&nbsp;    private Font findFontSizeToFit(Graphics2D g2d, String text, double targetWidth, Font baseFont) {
<b class="nc">&nbsp;        float size = 1.0f;</b>
&nbsp;        Font font;
&nbsp;        FontMetrics fm;
&nbsp;        
&nbsp;        do {
<b class="nc">&nbsp;            font = baseFont.deriveFont(size);</b>
<b class="nc">&nbsp;            g2d.setFont(font);</b>
<b class="nc">&nbsp;            fm = g2d.getFontMetrics();</b>
<b class="nc">&nbsp;            size += 0.5f;</b>
<b class="nc">&nbsp;        } while (fm.stringWidth(text) &lt; targetWidth);</b>
&nbsp;        
&nbsp;        // Volta um passo para garantir que não passou do tamanho
<b class="nc">&nbsp;        return baseFont.deriveFont(size - 0.5f);</b>
&nbsp;    }
&nbsp;
&nbsp;    // /**
&nbsp;    //  * Desenha todas as adjacências do grafo.
&nbsp;    //  * As adjacências são desenhadas como linhas laranja
&nbsp;    //  * conectando os centroides das propriedades dos proprietários.
&nbsp;    //  *
&nbsp;    //  * @param g2d O objeto Graphics2D usado para desenho
&nbsp;    //  */
&nbsp;    // private void drawAdjacencies(Graphics2D g2d) {
&nbsp;    //     g2d.setColor(Constants.ADJACENCY_LINE);
&nbsp;    //     g2d.setStroke(new BasicStroke(Constants.ADJACENCY_STROKE_WIDTH));
&nbsp;
&nbsp;    //     for (Cadastro cadastro : ownerGraph.getProperties()) {
&nbsp;    //         Set&lt;Cadastro&gt; adjacents = ownerGraph.getAdjacentProperties(cadastro);
&nbsp;    //         for (Cadastro adjacent : adjacents) {
&nbsp;    //             drawAdjacencyLine(g2d, cadastro, adjacent);
&nbsp;    //         }
&nbsp;    //     }
&nbsp;    // }
&nbsp;
&nbsp;    // /**
&nbsp;    //  * Desenha uma linha de adjacência entre duas propriedades.
&nbsp;    //  * A linha é desenhada entre os centroides das propriedades.
&nbsp;    //  *
&nbsp;    //  * @param g2d O objeto Graphics2D usado para desenho
&nbsp;    //  * @param prop1 Primeira propriedade
&nbsp;    //  * @param prop2 Segunda propriedade
&nbsp;    //  */
&nbsp;    // private void drawAdjacencyLine(Graphics2D g2d, Cadastro prop1, Cadastro prop2) {
&nbsp;    //     MultiPolygon shape1 = prop1.getShape();
&nbsp;    //     MultiPolygon shape2 = prop2.getShape();
&nbsp;        
&nbsp;    //     if (shape1 != null &amp;&amp; shape2 != null) {
&nbsp;    //         double x1 = shape1.getCentroid().getX();
&nbsp;    //         double y1 = shape1.getCentroid().getY();
&nbsp;    //         double x2 = shape2.getCentroid().getX();
&nbsp;    //         double y2 = shape2.getCentroid().getY();
&nbsp;            
&nbsp;    //         g2d.drawLine((int) x1, (int) y1, (int) x2, (int) y2);
&nbsp;    //     }
&nbsp;    // }
&nbsp;} 
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-05-17 22:49</div>
</div>
</body>
</html>
