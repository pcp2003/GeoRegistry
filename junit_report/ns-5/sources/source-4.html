


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > PropertyGraphPanel</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">ui</a>
</div>

<h1>Coverage Summary for Class: PropertyGraphPanel (ui)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">PropertyGraphPanel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/130)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package ui;
&nbsp;
&nbsp;import service.PropertyGraph;
&nbsp;import model.Cadastro;
&nbsp;import core.Constants;
&nbsp;import org.locationtech.jts.geom.Geometry;
&nbsp;import org.locationtech.jts.geom.MultiPolygon;
&nbsp;
&nbsp;import javax.swing.*;
&nbsp;import java.awt.*;
&nbsp;import java.awt.event.*;
&nbsp;import java.awt.geom.*;
&nbsp;import java.util.*;
&nbsp;
&nbsp;/**
&nbsp; * Painel para visualização de grafos de propriedades com funcionalidades interativas.
&nbsp; * Suporta zoom, deslocamento e seleção de propriedades.
&nbsp; * 
&nbsp; * @author Lei-G
&nbsp; * @version 1.0
&nbsp; */
&nbsp;public class PropertyGraphPanel extends JPanel implements MouseWheelListener, MouseListener, MouseMotionListener {
&nbsp;    /** Graph representing property adjacencies */
&nbsp;    private final PropertyGraph propertyGraph;
&nbsp;
&nbsp;    /** Last point recorded during mouse interaction */
&nbsp;    private Point2D lastPoint;
&nbsp;
&nbsp;    /** Current pan offset for the view */
<b class="nc">&nbsp;    private Point2D panOffset = new Point2D.Double(0, 0);</b>
&nbsp;
&nbsp;    /** Current zoom factor for the view */
<b class="nc">&nbsp;    private double zoomFactor = 1.0;</b>
&nbsp;
&nbsp;    /** Map of property IDs to their visual paths */
<b class="nc">&nbsp;    private final Map&lt;Integer, Path2D&gt; propertyPaths = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    /** Map of property IDs to their assigned colors */
<b class="nc">&nbsp;    private final Map&lt;Integer, Color&gt; propertyColors = new HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;    /** Cached affine transform for rendering */
<b class="nc">&nbsp;    private AffineTransform cachedTransform = null;</b>
&nbsp;
&nbsp;    /** Flag indicating if the transform needs to be recalculated */
<b class="nc">&nbsp;    private boolean transformDirty = true;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Cria um novo painel para visualização do grafo de propriedades.
&nbsp;     * 
&nbsp;     * @param propertyGraph O grafo de propriedades a visualizar
&nbsp;     */
<b class="nc">&nbsp;    public PropertyGraphPanel(PropertyGraph propertyGraph) {</b>
<b class="nc">&nbsp;        if (propertyGraph == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(Constants.NULL_GRAPH_ERROR);</b>
&nbsp;        }
<b class="nc">&nbsp;        this.propertyGraph = propertyGraph;</b>
<b class="nc">&nbsp;        setBackground(Color.WHITE);</b>
<b class="nc">&nbsp;        setPreferredSize(Constants.GRAPH_PANEL_SIZE);</b>
<b class="nc">&nbsp;        addMouseWheelListener(this);</b>
<b class="nc">&nbsp;        addMouseListener(this);</b>
<b class="nc">&nbsp;        addMouseMotionListener(this);</b>
&nbsp;
<b class="nc">&nbsp;        for (Cadastro cadastro : propertyGraph.getProperties()) {</b>
<b class="nc">&nbsp;            if (cadastro.getShape() != null) {</b>
<b class="nc">&nbsp;                propertyPaths.put(cadastro.getId(), toPath2D(cadastro.getShape()));</b>
<b class="nc">&nbsp;                propertyColors.put(cadastro.getId(), generateColorFromId(cadastro.getId()));</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected void paintComponent(Graphics g) {
&nbsp;        try {
<b class="nc">&nbsp;            super.paintComponent(g);</b>
<b class="nc">&nbsp;            Graphics2D g2d = (Graphics2D) g;</b>
<b class="nc">&nbsp;            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</b>
&nbsp;
<b class="nc">&nbsp;            if (transformDirty) {</b>
<b class="nc">&nbsp;                cachedTransform = calculateTransform();</b>
<b class="nc">&nbsp;                transformDirty = false;</b>
&nbsp;            }
<b class="nc">&nbsp;            g2d.setTransform(cachedTransform);</b>
&nbsp;
<b class="nc">&nbsp;            drawAdjacencies(g2d);</b>
&nbsp;
<b class="nc">&nbsp;            for (Cadastro cadastro : propertyGraph.getProperties()) {</b>
<b class="nc">&nbsp;                drawProperty(g2d, cadastro);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (Exception e) {</b>
<b class="nc">&nbsp;            drawError((Graphics2D) g);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void mouseWheelMoved(MouseWheelEvent e) {
<b class="nc">&nbsp;        if (!e.isControlDown()) return;  // Apenas aplica zoom se Ctrl estiver pressionado</b>
&nbsp;
<b class="nc">&nbsp;        double oldZoom = zoomFactor;</b>
<b class="nc">&nbsp;        double newZoom = zoomFactor;</b>
&nbsp;
<b class="nc">&nbsp;        if (e.getWheelRotation() &lt; 0) {</b>
<b class="nc">&nbsp;            newZoom = Math.min(zoomFactor + Constants.ZOOM_STEP, Constants.MAX_ZOOM);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            newZoom = Math.max(zoomFactor - Constants.ZOOM_STEP, Constants.MIN_ZOOM);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (oldZoom != newZoom) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (transformDirty) {</b>
<b class="nc">&nbsp;                    cachedTransform = calculateTransform();</b>
<b class="nc">&nbsp;                    transformDirty = false;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                Point2D mousePoint = e.getPoint();</b>
<b class="nc">&nbsp;                AffineTransform inverse = cachedTransform.createInverse();</b>
<b class="nc">&nbsp;                Point2D worldBeforeZoom = inverse.transform(mousePoint, null);</b>
&nbsp;
<b class="nc">&nbsp;                zoomFactor = newZoom;</b>
<b class="nc">&nbsp;                transformDirty = true;</b>
<b class="nc">&nbsp;                cachedTransform = calculateTransform();</b>
&nbsp;
<b class="nc">&nbsp;                inverse = cachedTransform.createInverse();</b>
<b class="nc">&nbsp;                Point2D worldAfterZoom = inverse.transform(mousePoint, null);</b>
&nbsp;
<b class="nc">&nbsp;                double dx = worldAfterZoom.getX() - worldBeforeZoom.getX();</b>
<b class="nc">&nbsp;                double dy = worldAfterZoom.getY() - worldBeforeZoom.getY();</b>
&nbsp;
<b class="nc">&nbsp;                panOffset.setLocation(</b>
<b class="nc">&nbsp;                        panOffset.getX() + dx * cachedTransform.getScaleX(),</b>
<b class="nc">&nbsp;                        panOffset.getY() - dy * cachedTransform.getScaleY()</b>
&nbsp;                );
&nbsp;
<b class="nc">&nbsp;                transformDirty = true;</b>
<b class="nc">&nbsp;                repaint();</b>
<b class="nc">&nbsp;            } catch (NoninvertibleTransformException ex) {</b>
<b class="nc">&nbsp;                ex.printStackTrace();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    @Override
&nbsp;    public void mousePressed(MouseEvent e) {
<b class="nc">&nbsp;        if (e.getButton() == MouseEvent.BUTTON1) {</b>
<b class="nc">&nbsp;            lastPoint = e.getPoint();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void mouseReleased(MouseEvent e) {
<b class="nc">&nbsp;        if (e.getButton() == MouseEvent.BUTTON1) {</b>
<b class="nc">&nbsp;            lastPoint = null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public void mouseDragged(MouseEvent e) {
<b class="nc">&nbsp;        if (lastPoint != null) {</b>
<b class="nc">&nbsp;            double dx = e.getX() - lastPoint.getX();</b>
<b class="nc">&nbsp;            double dy = e.getY() - lastPoint.getY();</b>
<b class="nc">&nbsp;            panOffset.setLocation(panOffset.getX() + dx, panOffset.getY() + dy);</b>
<b class="nc">&nbsp;            lastPoint = e.getPoint();</b>
<b class="nc">&nbsp;            transformDirty = true;</b>
<b class="nc">&nbsp;            repaint();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @Override public void mouseClicked(MouseEvent e) {}</b>
<b class="nc">&nbsp;    @Override public void mouseEntered(MouseEvent e) {}</b>
<b class="nc">&nbsp;    @Override public void mouseExited(MouseEvent e) {}</b>
<b class="nc">&nbsp;    @Override public void mouseMoved(MouseEvent e) {}</b>
&nbsp;
&nbsp;    private void drawError(Graphics2D g2d) {
<b class="nc">&nbsp;        g2d.setColor(Color.RED);</b>
<b class="nc">&nbsp;        g2d.drawString(Constants.RENDER_ERROR, 10, 20);</b>
&nbsp;    }
&nbsp;
&nbsp;    private AffineTransform calculateTransform() {
<b class="nc">&nbsp;        double minX = Double.MAX_VALUE;</b>
<b class="nc">&nbsp;        double maxX = Double.MIN_VALUE;</b>
<b class="nc">&nbsp;        double minY = Double.MAX_VALUE;</b>
<b class="nc">&nbsp;        double maxY = Double.MIN_VALUE;</b>
&nbsp;
<b class="nc">&nbsp;        for (Cadastro cadastro : propertyGraph.getProperties()) {</b>
<b class="nc">&nbsp;            MultiPolygon shape = cadastro.getShape();</b>
<b class="nc">&nbsp;            if (shape != null) {</b>
<b class="nc">&nbsp;                minX = Math.min(minX, shape.getEnvelopeInternal().getMinX());</b>
<b class="nc">&nbsp;                maxX = Math.max(maxX, shape.getEnvelopeInternal().getMaxX());</b>
<b class="nc">&nbsp;                minY = Math.min(minY, shape.getEnvelopeInternal().getMinY());</b>
<b class="nc">&nbsp;                maxY = Math.max(maxY, shape.getEnvelopeInternal().getMaxY());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        double width = maxX - minX;</b>
<b class="nc">&nbsp;        double height = maxY - minY;</b>
<b class="nc">&nbsp;        double scaleX = (getWidth() * Constants.GRAPH_SCALE_FACTOR) / width;</b>
<b class="nc">&nbsp;        double scaleY = (getHeight() * Constants.GRAPH_SCALE_FACTOR) / height;</b>
<b class="nc">&nbsp;        double scale = Math.min(scaleX, scaleY);</b>
&nbsp;
<b class="nc">&nbsp;        AffineTransform transform = new AffineTransform();</b>
<b class="nc">&nbsp;        transform.translate(getWidth() / 2 + panOffset.getX(), getHeight() / 2 + panOffset.getY());</b>
<b class="nc">&nbsp;        transform.scale(1, -1);</b>
<b class="nc">&nbsp;        transform.scale(scale * zoomFactor, scale * zoomFactor);</b>
<b class="nc">&nbsp;        transform.translate(-(minX + width / 2), -(minY + height / 2));</b>
<b class="nc">&nbsp;        return transform;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void drawProperty(Graphics2D g2d, Cadastro cadastro) {
<b class="nc">&nbsp;        Path2D path = propertyPaths.get(cadastro.getId());</b>
<b class="nc">&nbsp;        Color color = propertyColors.get(cadastro.getId());</b>
<b class="nc">&nbsp;        if (path != null &amp;&amp; color != null) {</b>
<b class="nc">&nbsp;            g2d.setColor(color);</b>
<b class="nc">&nbsp;            g2d.fill(path);</b>
<b class="nc">&nbsp;            g2d.draw(path);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private Color generateColorFromId(int id) {
<b class="nc">&nbsp;        int r = (id * 37) % 256;</b>
<b class="nc">&nbsp;        int g = (id * 67) % 256;</b>
<b class="nc">&nbsp;        int b = (id * 97) % 256;</b>
<b class="nc">&nbsp;        return new Color(r, g, b);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void drawAdjacencies(Graphics2D g2d) {
<b class="nc">&nbsp;        g2d.setColor(Constants.ADJACENCY_LINE);</b>
<b class="nc">&nbsp;        g2d.setStroke(new BasicStroke(Constants.ADJACENCY_STROKE_WIDTH));</b>
&nbsp;
<b class="nc">&nbsp;        for (Cadastro cadastro : propertyGraph.getProperties()) {</b>
<b class="nc">&nbsp;            Set&lt;Cadastro&gt; adjacents = propertyGraph.getAdjacentProperties(cadastro);</b>
<b class="nc">&nbsp;            for (Cadastro adjacent : adjacents) {</b>
<b class="nc">&nbsp;                drawAdjacencyLine(g2d, cadastro, adjacent);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void drawAdjacencyLine(Graphics2D g2d, Cadastro prop1, Cadastro prop2) {
<b class="nc">&nbsp;        MultiPolygon shape1 = prop1.getShape();</b>
<b class="nc">&nbsp;        MultiPolygon shape2 = prop2.getShape();</b>
&nbsp;
<b class="nc">&nbsp;        if (shape1 != null &amp;&amp; shape2 != null) {</b>
<b class="nc">&nbsp;            double x1 = shape1.getCentroid().getX();</b>
<b class="nc">&nbsp;            double y1 = shape1.getCentroid().getY();</b>
<b class="nc">&nbsp;            double x2 = shape2.getCentroid().getX();</b>
<b class="nc">&nbsp;            double y2 = shape2.getCentroid().getY();</b>
&nbsp;
<b class="nc">&nbsp;            g2d.drawLine((int) x1, (int) y1, (int) x2, (int) y2);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private Path2D toPath2D(Geometry geometry) {
<b class="nc">&nbsp;        Path2D path = new Path2D.Double();</b>
<b class="nc">&nbsp;        for (int i = 0; i &lt; geometry.getNumPoints(); i++) {</b>
<b class="nc">&nbsp;            double x = geometry.getCoordinates()[i].x;</b>
<b class="nc">&nbsp;            double y = geometry.getCoordinates()[i].y;</b>
&nbsp;
<b class="nc">&nbsp;            if (i == 0) {</b>
<b class="nc">&nbsp;                path.moveTo(x, y);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                path.lineTo(x, y);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        path.closePath();</b>
<b class="nc">&nbsp;        return path;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-05-17 22:49</div>
</div>
</body>
</html>
